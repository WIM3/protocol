/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface IAmmInterface extends ethers.utils.Interface {
  functions: {
    "calcBaseAssetAfterLiquidityMigration((int256),(uint256),(uint256))": FunctionFragment;
    "calcFee((uint256))": FunctionFragment;
    "getBaseAssetDelta()": FunctionFragment;
    "getBaseAssetDeltaThisFundingPeriod()": FunctionFragment;
    "getCumulativeNotional()": FunctionFragment;
    "getInputPrice(uint8,(uint256))": FunctionFragment;
    "getInputPriceWithReserves(uint8,(uint256),(uint256),(uint256))": FunctionFragment;
    "getInputTwap(uint8,(uint256))": FunctionFragment;
    "getLiquidityChangedSnapshots(uint256)": FunctionFragment;
    "getLiquidityHistoryLength()": FunctionFragment;
    "getMaxHoldingBaseAsset()": FunctionFragment;
    "getOpenInterestNotionalCap()": FunctionFragment;
    "getOutputPrice(uint8,(uint256))": FunctionFragment;
    "getOutputPriceWithReserves(uint8,(uint256),(uint256),(uint256))": FunctionFragment;
    "getOutputTwap(uint8,(uint256))": FunctionFragment;
    "getSettlementPrice()": FunctionFragment;
    "getSpotPrice()": FunctionFragment;
    "getUnderlyingPrice()": FunctionFragment;
    "isOverFluctuationLimit(uint8,(uint256))": FunctionFragment;
    "isOverSpreadLimit()": FunctionFragment;
    "open()": FunctionFragment;
    "quoteAsset()": FunctionFragment;
    "settleFunding()": FunctionFragment;
    "shutdown()": FunctionFragment;
    "swapInput(uint8,(uint256),(uint256),bool)": FunctionFragment;
    "swapOutput(uint8,(uint256),(uint256))": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "calcBaseAssetAfterLiquidityMigration",
    values: [{ d: BigNumberish }, { d: BigNumberish }, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "calcFee",
    values: [{ d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "getBaseAssetDelta",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBaseAssetDeltaThisFundingPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCumulativeNotional",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInputPrice",
    values: [BigNumberish, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "getInputPriceWithReserves",
    values: [
      BigNumberish,
      { d: BigNumberish },
      { d: BigNumberish },
      { d: BigNumberish }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getInputTwap",
    values: [BigNumberish, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityChangedSnapshots",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityHistoryLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxHoldingBaseAsset",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOpenInterestNotionalCap",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOutputPrice",
    values: [BigNumberish, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "getOutputPriceWithReserves",
    values: [
      BigNumberish,
      { d: BigNumberish },
      { d: BigNumberish },
      { d: BigNumberish }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getOutputTwap",
    values: [BigNumberish, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "getSettlementPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSpotPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getUnderlyingPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isOverFluctuationLimit",
    values: [BigNumberish, { d: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "isOverSpreadLimit",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "open", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "quoteAsset",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "settleFunding",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "shutdown", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "swapInput",
    values: [BigNumberish, { d: BigNumberish }, { d: BigNumberish }, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "swapOutput",
    values: [BigNumberish, { d: BigNumberish }, { d: BigNumberish }]
  ): string;

  decodeFunctionResult(
    functionFragment: "calcBaseAssetAfterLiquidityMigration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "calcFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBaseAssetDelta",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBaseAssetDeltaThisFundingPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCumulativeNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputPriceWithReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputTwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityChangedSnapshots",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityHistoryLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxHoldingBaseAsset",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOpenInterestNotionalCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOutputPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOutputPriceWithReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOutputTwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSettlementPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSpotPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUnderlyingPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOverFluctuationLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOverSpreadLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "open", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "quoteAsset", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "settleFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "shutdown", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "swapInput", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "swapOutput", data: BytesLike): Result;

  events: {};
}

export class IAmm extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IAmmInterface;

  functions: {
    calcBaseAssetAfterLiquidityMigration(
      _baseAssetAmount: { d: BigNumberish },
      _fromQuoteReserve: { d: BigNumberish },
      _fromBaseReserve: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    calcFee(
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<
      [[BigNumber] & { d: BigNumber }, [BigNumber] & { d: BigNumber }]
    >;

    getBaseAssetDelta(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getBaseAssetDeltaThisFundingPeriod(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getCumulativeNotional(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getInputPrice(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getInputPriceWithReserves(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getInputTwap(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getLiquidityChangedSnapshots(
      i: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [
          [BigNumber] & { d: BigNumber },
          [BigNumber] & { d: BigNumber },
          [BigNumber] & { d: BigNumber },
          [BigNumber] & { d: BigNumber }
        ] & {
          cumulativeNotional: [BigNumber] & { d: BigNumber };
          quoteAssetReserve: [BigNumber] & { d: BigNumber };
          baseAssetReserve: [BigNumber] & { d: BigNumber };
          totalPositionSize: [BigNumber] & { d: BigNumber };
        }
      ]
    >;

    getLiquidityHistoryLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMaxHoldingBaseAsset(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getOpenInterestNotionalCap(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getOutputPrice(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getOutputPriceWithReserves(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getOutputTwap(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getSettlementPrice(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getSpotPrice(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    getUnderlyingPrice(
      overrides?: CallOverrides
    ): Promise<[[BigNumber] & { d: BigNumber }]>;

    isOverFluctuationLimit(
      _dirOfBase: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isOverSpreadLimit(overrides?: CallOverrides): Promise<[boolean]>;

    open(overrides?: CallOverrides): Promise<[boolean]>;

    quoteAsset(overrides?: CallOverrides): Promise<[string]>;

    settleFunding(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    shutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapInput(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _baseAssetAmountLimit: { d: BigNumberish },
      _canOverFluctuationLimit: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapOutput(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetAmountLimit: { d: BigNumberish },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  calcBaseAssetAfterLiquidityMigration(
    _baseAssetAmount: { d: BigNumberish },
    _fromQuoteReserve: { d: BigNumberish },
    _fromBaseReserve: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  calcFee(
    _quoteAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[[BigNumber] & { d: BigNumber }, [BigNumber] & { d: BigNumber }]>;

  getBaseAssetDelta(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getBaseAssetDeltaThisFundingPeriod(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getCumulativeNotional(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getInputPrice(
    _dir: BigNumberish,
    _quoteAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getInputPriceWithReserves(
    _dir: BigNumberish,
    _quoteAssetAmount: { d: BigNumberish },
    _quoteAssetPoolAmount: { d: BigNumberish },
    _baseAssetPoolAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getInputTwap(
    _dir: BigNumberish,
    _quoteAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getLiquidityChangedSnapshots(
    i: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      [BigNumber] & { d: BigNumber },
      [BigNumber] & { d: BigNumber },
      [BigNumber] & { d: BigNumber },
      [BigNumber] & { d: BigNumber }
    ] & {
      cumulativeNotional: [BigNumber] & { d: BigNumber };
      quoteAssetReserve: [BigNumber] & { d: BigNumber };
      baseAssetReserve: [BigNumber] & { d: BigNumber };
      totalPositionSize: [BigNumber] & { d: BigNumber };
    }
  >;

  getLiquidityHistoryLength(overrides?: CallOverrides): Promise<BigNumber>;

  getMaxHoldingBaseAsset(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getOpenInterestNotionalCap(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getOutputPrice(
    _dir: BigNumberish,
    _baseAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getOutputPriceWithReserves(
    _dir: BigNumberish,
    _baseAssetAmount: { d: BigNumberish },
    _quoteAssetPoolAmount: { d: BigNumberish },
    _baseAssetPoolAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getOutputTwap(
    _dir: BigNumberish,
    _baseAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getSettlementPrice(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getSpotPrice(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  getUnderlyingPrice(
    overrides?: CallOverrides
  ): Promise<[BigNumber] & { d: BigNumber }>;

  isOverFluctuationLimit(
    _dirOfBase: BigNumberish,
    _baseAssetAmount: { d: BigNumberish },
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOverSpreadLimit(overrides?: CallOverrides): Promise<boolean>;

  open(overrides?: CallOverrides): Promise<boolean>;

  quoteAsset(overrides?: CallOverrides): Promise<string>;

  settleFunding(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  shutdown(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapInput(
    _dir: BigNumberish,
    _quoteAssetAmount: { d: BigNumberish },
    _baseAssetAmountLimit: { d: BigNumberish },
    _canOverFluctuationLimit: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapOutput(
    _dir: BigNumberish,
    _baseAssetAmount: { d: BigNumberish },
    _quoteAssetAmountLimit: { d: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    calcBaseAssetAfterLiquidityMigration(
      _baseAssetAmount: { d: BigNumberish },
      _fromQuoteReserve: { d: BigNumberish },
      _fromBaseReserve: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    calcFee(
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<
      [[BigNumber] & { d: BigNumber }, [BigNumber] & { d: BigNumber }]
    >;

    getBaseAssetDelta(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getBaseAssetDeltaThisFundingPeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getCumulativeNotional(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getInputPrice(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getInputPriceWithReserves(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getInputTwap(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getLiquidityChangedSnapshots(
      i: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber] & { d: BigNumber },
        [BigNumber] & { d: BigNumber },
        [BigNumber] & { d: BigNumber },
        [BigNumber] & { d: BigNumber }
      ] & {
        cumulativeNotional: [BigNumber] & { d: BigNumber };
        quoteAssetReserve: [BigNumber] & { d: BigNumber };
        baseAssetReserve: [BigNumber] & { d: BigNumber };
        totalPositionSize: [BigNumber] & { d: BigNumber };
      }
    >;

    getLiquidityHistoryLength(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxHoldingBaseAsset(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getOpenInterestNotionalCap(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getOutputPrice(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getOutputPriceWithReserves(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getOutputTwap(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getSettlementPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getSpotPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    getUnderlyingPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    isOverFluctuationLimit(
      _dirOfBase: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOverSpreadLimit(overrides?: CallOverrides): Promise<boolean>;

    open(overrides?: CallOverrides): Promise<boolean>;

    quoteAsset(overrides?: CallOverrides): Promise<string>;

    settleFunding(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    shutdown(overrides?: CallOverrides): Promise<void>;

    swapInput(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _baseAssetAmountLimit: { d: BigNumberish },
      _canOverFluctuationLimit: boolean,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;

    swapOutput(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetAmountLimit: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { d: BigNumber }>;
  };

  filters: {};

  estimateGas: {
    calcBaseAssetAfterLiquidityMigration(
      _baseAssetAmount: { d: BigNumberish },
      _fromQuoteReserve: { d: BigNumberish },
      _fromBaseReserve: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calcFee(
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBaseAssetDelta(overrides?: CallOverrides): Promise<BigNumber>;

    getBaseAssetDeltaThisFundingPeriod(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCumulativeNotional(overrides?: CallOverrides): Promise<BigNumber>;

    getInputPrice(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInputPriceWithReserves(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInputTwap(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityChangedSnapshots(
      i: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLiquidityHistoryLength(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxHoldingBaseAsset(overrides?: CallOverrides): Promise<BigNumber>;

    getOpenInterestNotionalCap(overrides?: CallOverrides): Promise<BigNumber>;

    getOutputPrice(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOutputPriceWithReserves(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOutputTwap(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSettlementPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getSpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getUnderlyingPrice(overrides?: CallOverrides): Promise<BigNumber>;

    isOverFluctuationLimit(
      _dirOfBase: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOverSpreadLimit(overrides?: CallOverrides): Promise<BigNumber>;

    open(overrides?: CallOverrides): Promise<BigNumber>;

    quoteAsset(overrides?: CallOverrides): Promise<BigNumber>;

    settleFunding(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    shutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapInput(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _baseAssetAmountLimit: { d: BigNumberish },
      _canOverFluctuationLimit: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapOutput(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetAmountLimit: { d: BigNumberish },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    calcBaseAssetAfterLiquidityMigration(
      _baseAssetAmount: { d: BigNumberish },
      _fromQuoteReserve: { d: BigNumberish },
      _fromBaseReserve: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calcFee(
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBaseAssetDelta(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBaseAssetDeltaThisFundingPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCumulativeNotional(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInputPrice(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInputPriceWithReserves(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInputTwap(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityChangedSnapshots(
      i: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityHistoryLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxHoldingBaseAsset(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOpenInterestNotionalCap(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOutputPrice(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOutputPriceWithReserves(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetPoolAmount: { d: BigNumberish },
      _baseAssetPoolAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOutputTwap(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSettlementPrice(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSpotPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getUnderlyingPrice(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOverFluctuationLimit(
      _dirOfBase: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOverSpreadLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    open(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    quoteAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    settleFunding(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    shutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapInput(
      _dir: BigNumberish,
      _quoteAssetAmount: { d: BigNumberish },
      _baseAssetAmountLimit: { d: BigNumberish },
      _canOverFluctuationLimit: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapOutput(
      _dir: BigNumberish,
      _baseAssetAmount: { d: BigNumberish },
      _quoteAssetAmountLimit: { d: BigNumberish },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
